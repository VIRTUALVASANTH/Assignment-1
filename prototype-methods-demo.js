// Author: Generated by AI code assistant â€” Reviewed by: Vasanth
// Run: node prototype-methods-demo.js

console.log('=== JAVASCRIPT OBJECT PROTOTYPE METHODS DEMONSTRATION ===\n');

// Constructor property demonstration
console.log('--- constructor property - Show instance.constructor === FunctionName ---');
class Person {
  constructor(name) {
    this.name = name;
  }
}

const person = new Person('John');
console.log('Person instance:', person);
console.log('person.constructor === Person:', person.constructor === Person);
console.log('person.constructor.name:', person.constructor.name);

// hasOwnProperty vs inherited property demonstration
console.log('\n--- hasOwnProperty vs inherited property - Show own vs prototype properties ---');
function Animal(name) {
  this.name = name; // own property
}

Animal.prototype.species = 'Unknown'; // prototype property
Animal.prototype.makeSound = function() { return 'Some sound'; }; // prototype method

const cat = new Animal('Whiskers');
console.log('Cat object:', cat);
console.log('cat.hasOwnProperty("name"):', cat.hasOwnProperty('name')); // true - own property
console.log('cat.hasOwnProperty("species"):', cat.hasOwnProperty('species')); // false - inherited
console.log('cat.hasOwnProperty("makeSound"):', cat.hasOwnProperty('makeSound')); // false - inherited
console.log('cat.species:', cat.species); // accessible via prototype chain
console.log('cat.makeSound():', cat.makeSound()); // accessible via prototype chain

// isPrototypeOf demonstration
console.log('\n--- isPrototypeOf - Show prototype chain check ---');
const animalProto = Animal.prototype;
console.log('animalProto.isPrototypeOf(cat):', animalProto.isPrototypeOf(cat)); // true
console.log('Object.prototype.isPrototypeOf(cat):', Object.prototype.isPrototypeOf(cat)); // true
console.log('Array.prototype.isPrototypeOf(cat):', Array.prototype.isPrototypeOf(cat)); // false

// propertyIsEnumerable demonstration
console.log('\n--- propertyIsEnumerable - Show enumerability behavior ---');
const enumObj = {
  enumerableProp: 'enumerable',
  [Symbol('symbolProp')]: 'symbol value'
};

Object.defineProperty(enumObj, 'nonEnumerableProp', {
  value: 'non-enumerable',
  enumerable: false
});

console.log('Object with mixed properties:', enumObj);
console.log('enumerableProp is enumerable:', enumObj.propertyIsEnumerable('enumerableProp')); // true
console.log('nonEnumerableProp is enumerable:', enumObj.propertyIsEnumerable('nonEnumerableProp')); // false
console.log('toString is enumerable:', enumObj.propertyIsEnumerable('toString')); // false - inherited
console.log('Symbol property is enumerable:', enumObj.propertyIsEnumerable(Symbol('symbolProp'))); // true

// toLocaleString demonstration
console.log('\n--- toLocaleString - Brief invocation ---');
const date = new Date();
const number = 1234567.89;
console.log('Date toLocaleString:', date.toLocaleString());
console.log('Number toLocaleString:', number.toLocaleString());
console.log('Object toLocaleString:', { x: 1, y: 2 }.toLocaleString()); // same as toString

// toString demonstration - default and overridden
console.log('\n--- toString - Default and overridden toString ---');
console.log('Default object toString:', { x: 1, y: 2 }.toString());
console.log('Array toString:', [1, 2, 3].toString());
console.log('Function toString:', function() {}.toString().substring(0, 20) + '...');

// Custom class with overridden toString
class Product {
  constructor(name, price) {
    this.name = name;
    this.price = price;
  }
  
  toString() {
    return `Product: ${this.name} - $${this.price}`;
  }
}

const product = new Product('Laptop', 999);
console.log('Custom toString:', product.toString());
console.log('String concatenation:', 'Item: ' + product);

// valueOf demonstration
console.log('\n--- valueOf - Override to produce primitive and show behavior ---');
class Counter {
  constructor(initial = 0) {
    this.count = initial;
  }
  
  increment() {
    this.count++;
    return this;
  }
  
  valueOf() {
    return this.count; // returns primitive number
  }
  
  toString() {
    return `Counter(${this.count})`;
  }
}

const counter = new Counter(5);
console.log('Counter object:', counter);
console.log('Counter valueOf():', counter.valueOf());
console.log('Counter in arithmetic:', counter + 10); // uses valueOf
console.log('Counter in comparison:', counter > 3); // uses valueOf
console.log('Counter in string context:', 'Count: ' + counter); // uses toString

// Legacy __proto__ demonstration (marked as legacy)
console.log('\n--- __proto__ - Legacy prototype access (use getPrototypeOf/setPrototypeOf instead) ---');
const legacyObj = { a: 1 };
console.log('Object with __proto__:', legacyObj);
console.log('Legacy __proto__ access:', legacyObj.__proto__ === Object.prototype); // true
console.log('Modern getPrototypeOf:', Object.getPrototypeOf(legacyObj) === Object.prototype); // true

// Demonstrate __proto__ chain
const child = { b: 2 };
child.__proto__ = legacyObj; // LEGACY - prefer Object.setPrototypeOf
console.log('Child with legacy __proto__:', child);
console.log('Child can access parent property:', child.a); // 1
console.log('Modern way to check prototype:', Object.getPrototypeOf(child) === legacyObj); // true

console.log('\n=== END PROTOTYPE DEMO ===');
